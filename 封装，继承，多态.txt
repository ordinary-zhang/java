1.封装，继承，多态的概念
   封装：  
	   也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
	   利用抽象数据类型将数据和基于数据的操作封装在一起，用户是无需知道对象内部的细节，但可以通过该对象对外提供的接口来访问该对象。
	   
	   1. 保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==>数据封装。
	   2. 方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==>方法封装。
		
	使用封装有三大好处：
	1、良好的封装能够减少耦合。
	2、类内部的结构可以自由修改。
	3、可以对成员进行更精确的控制。
	

访问权限控制级别
	 访问范围    private	default		protected		public
	 同一个类     可以        可以         可以          可以
	 同一个包                 可以         可以          可以
	 子类中                                可以          可以
	 全局范围                                            可以

 
继承：
	是指可以让某个类型的对象获得另一个类型的对象的属性和方法。是一种按级分类的概念。
	通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。
	诚然，继承定义了类如何相互关联，共享特性。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，
	创建的新类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。
	
注意：1、子类拥有父类非private的属性和方法。
	  2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。

谨慎继承
	在这里我们需要明确，继承存在如下缺陷：
	1、父类变，子类就必须变。
	2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。
	3、继承是一种强耦合关系。	

	
多态：
	1、“一个接口，多种方法”
	同一操作作用于不同的对象，产生不同的执行结果。
	 
	多态的三个条件:
		a.    继承的存在(继承是多态的基础,没有继承就没有多态).
		b.    子类重写父类的方法(多态下调用子类重写的方法).
		c.    父类引用变量指向子类对象(子类到父类的类型转换).
		
	重载（overload）和重写（override）是实现多态的两种主要方式。
	对于面向对象而言，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，
	它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。
	而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。
	
实现形式
   在Java中有两种形式可以实现多态：继承和接口。

1、基于继承实现的多态
    基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。
    如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。
	这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。   
	
2、基于接口实现的多态
    在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。
    继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，
	它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。	
	

例题：
public class A {  
    public String show(D obj) {  
        return ("A and D");  
    }  
  
    public String show(A obj) {  
        return ("A and A");  
    }   
  
}  
  
public class B extends A{  
    public String show(B obj){  
        return ("B and B");  
    }  
      
    public String show(A obj){  
        return ("B and A");  
    }   
}  
  
public class C extends B{  
  
}  
  
public class D extends B{  
  
}  
  
public class Test {  
    public static void main(String[] args) {  
        A a1 = new A();  
        A a2 = new B();  
        B b = new B();  
        C c = new C();  
        D d = new D();  
          
        System.out.println("1--" + a1.show(b));  
        System.out.println("2--" + a1.show(c));  
        System.out.println("3--" + a1.show(d));  
        System.out.println("4--" + a2.show(b));  
        System.out.println("5--" + a2.show(c));  
        System.out.println("6--" + a2.show(d));  
        System.out.println("7--" + b.show(b));  
        System.out.println("8--" + b.show(c));  
        System.out.println("9--" + b.show(d));        
    }  
} 

参考博客：
https://blog.csdn.net/jianyuerensheng/article/details/51602015
https://www.cnblogs.com/1711643472qq/p/5909839.html
https://blog.csdn.net/c_w_d/article/details/52982191


六大基本原则

单一职责原则SRP(Single Responsibility Principle)
是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

开放封闭原则OCP(Open－Close Principle) 
一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只有服务端功能，而现在要加入客户端功能，
那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

里氏替换原则(the Liskov Substitution Principle LSP) 
子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，
也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

依赖倒置原则(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，
这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到
了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。

接口分离原则(the Interface Segregation Principle ISP) 
模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来
一句话总结：就好比鱼和人两个类，鱼是游泳和腮呼吸两个动作，人是走路和吃饭两个动作，这些动作不能写在一个接口里面，把这四个动作都包含了。
要拆成专门对鱼和人的两个接口才行。

迪米特法则
迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。
英文简写为: LoD.迪米特法则可以简单说成：talk only to your immediate friends。 对于面向OOD来说，又被解释为下面几种方式：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

　　迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。
迪米特法则不希望类直接建立直接的接触。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。
有兴趣可以研究一下设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。
	
参考博客：https://blog.csdn.net/cq361106306/article/details/38708967
https://www.cnblogs.com/1711643472qq/p/5909839.html	